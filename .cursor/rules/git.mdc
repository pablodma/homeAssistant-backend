---
description: Branching model y convenciones Git
globs:
  - "**/*"
alwaysApply: true
---

# Git - Branching Model

## Estrategia: GitHub Flow

```
main ────●────●────●────●────●──── (siempre deployable)
          \        /
           ●──●──●
           feature/xxx
```

## Ramas

| Rama | Propósito | Deploy |
|------|-----------|--------|
| `main` | Producción | Auto → Railway |
| `feature/*` | Nuevas funcionalidades | - |
| `fix/*` | Corrección de bugs | - |
| `hotfix/*` | Fixes urgentes en prod | - |

## Reglas

1. **`main` siempre deployable** - No commitear código roto
2. **Branch desde `main`** - Siempre crear ramas desde main actualizado
3. **PRs para merge** - No push directo a main (excepto hotfixes críticos)
4. **Commits atómicos** - Un cambio lógico por commit

## Convención de Commits

Formato: `tipo: descripción corta`

| Tipo | Uso |
|------|-----|
| `feat` | Nueva funcionalidad |
| `fix` | Corrección de bug |
| `docs` | Documentación |
| `refactor` | Refactoring sin cambio funcional |
| `test` | Tests |
| `chore` | Mantenimiento, deps |

**Ejemplos:**
- `feat: add expense categories endpoint`
- `fix: correct tenant isolation in queries`
- `docs: update API documentation`

## Workflow

```bash
# 1. Actualizar main
git checkout main
git pull origin main

# 2. Crear branch
git checkout -b feature/nueva-funcionalidad

# 3. Desarrollar y commitear
git add .
git commit -m "feat: descripción"

# 4. Push y PR
git push -u origin feature/nueva-funcionalidad
# Crear PR en GitHub

# 5. Después del merge, limpiar
git checkout main
git pull origin main
git branch -d feature/nueva-funcionalidad
```

## NO hacer

- ❌ Push directo a `main` sin verificar build
- ❌ Commits con mensaje genérico ("fix", "update", "wip")
- ❌ Branches de larga duración (>1 semana sin merge)
- ❌ Merge sin verificar que CI pase
